<?
# Author: John Vasko III
# Contents/Description: generic process for all search submissions
# Known Issues: default case is relied on in switch statements for added flexibility

// TRANSLATIONS for messages
add_translation('element', 'transaction_complete');
add_translation('element', 'lock_contact_name');
add_translation('element', 'error_does_not_exist');

// DO Translation for message
do_translation($key, $translation, $_SESSION['dialect']['dialect_id'], $_SESSION['login']['login_user_id']);

$process = array(); // Sent to process
$interpret = array(); // Interpreted from $process

$process['form_info'] = get_search_header_1();
foreach($process['form_info'] as $k1 => $v1)
	$process['form_info'][$k1] = get_gp($k1);

$process['search_miscellaneous'] = array(
	'keyword' => '',
	'asearch_on' => '', # TODO allow asearch option!
	'child' => '',
	'referrer' => '',
	$process['form_info']['type'] . '_uid' => '',
);

if (get_gp('keyword'))
	$interpret['lookup']['keyword'] = get_gp('keyword');

foreach($process['search_miscellaneous'] as $k1 => $v1)
	$process['search_miscellaneous'][$k1] = get_gp($k1);

$process['search_content_1'] = get_search_content_1($process['form_info']['type']);
if ($process['search_content_1'])
foreach($process['search_content_1'] as $k1 => $v1)
	$process['search_content_1'][$k1] = get_gp($k1);

$process['search_content_2'] = get_search_content_2($interpret['form_info']['type']);
if ($process['search_content_2'])
foreach($process['search_content_2'] as $k1 => $v1)
	$process['search_content_2'][$k1] = get_gp($k1);

contact_user_mixed_split('search_content_2', 'lock_');
contact_user_mixed_split('search_content_1', '');

if ($process) {
	foreach($process as $k1 => $v1) {
		process_data_translation($k1); # get [id]s
		process_does_not_exist($k1); # error checking
		process_does_exist($k1); # error checking
	}
}



// MORE ERROR CHECKING

// TODO put this in the does not exist function!
foreach($process as $k1 => $v1)
if ($v1['kind_name_name'] && !$interpret['lookup']['kind_name_id'])
	$interpret['message'] = tt('element', 'kind_name') . ' + ' . tt('element', 'kind_name_name') . ' : ' . tt('element', 'error_does_not_exist');

# this if never hits a process_failure() so why make a $interpret['message']?
# is this supposed to be a warning? seems like it should be an error...
if (str_match('_view', $x['page']['name'])) {
	if (!$interpret['message']) {
		switch($x['page']['name']) {
			case 'contact_view':
				if (!isset_gp('lock_user_name') && !isset_gp('lock_contact_name'))
					$interpret['message'] = tt('element', 'lock_contact_user_mixed') . ' : ' . tt('element', 'error_not_set');

			break;
			default:
				if (!get_gp('child'))
					$interpret['message'] = tt('element', 'child') . ' : ' . tt('element', 'error_not_set');
			break;
		}
	}
}

// FAILURE!
# needed? 2012-02-01
if (preg_match('/\_view/', $process['referrer'])) {
	switch($process['referrer']) {
		case 'contact_view':
			$interpret['location'] = $x['..'] . '?child=' . $process['child'] . '&lock_contact_id=' . $interpret['lock_contact_id'];
			process_failure($interpret['message'], $interpret['location']);
		break;
		default:
			$interpret['location'] = $x['..'] . '?child=' . $process['child'] . '&' . preg_replace('/\_view/', '_id', $process['referrer']) . '=' . $interpret[preg_replace('/\_view/', '_id', $process['referrer'])];
			process_failure($interpret['message'], $interpret['location']);
		break;
	}
}

process_failure($interpret['message']);





if ($process)
foreach($process as $k1 => $v1) {
	if ($v1)
	foreach($v1 as $k2 => $v2) {
		if ($v2 == '') {
			$s1 = get_interpreted_variable($k2);
			$interpret['lookup'][$s1] = '';
		}
	}
}

# initial page loading
$interpret['lookup']['page'] = '';
$interpret['lookup']['focus'] = '';
$interpret['lookup']['preview'] = array();
$interpret['lookup']['expand'] = array();

if ($interpret['lookup'])
	$s1 = http_build_query($interpret['lookup']);
else
	$s1 = '';

// SUCCESS
#process_success(tt('element', 'transaction_complete'), $x['..'] . get_q_query($x['level'], $s1));
process_success(tt('element', 'transaction_complete'), $x['..'] . ffm($s1, -1));



# why not just use:
# http://www.php.net/manual/en/function.http-build-query.php
# and make sure anything in the lookup array will be retuned... eh lests just try for now...
/*
$interpret['query'] = array();
may be needed if we have problems submitting searches... 2012-02-01
foreach($process as $k1 => $v1)
foreach($v1 as $k2 => $v2) {
	if (!empty($v2) && preg_match('/_uid/', $k2))
		$interpret['query'][] = $k2 . '=' . to_url($v2);
	else {
		switch($k2) {
			case 'asearch_on':
			case 'keyword':
			case 'child':
				if ($interpret['lookup'][$k2])
					$interpret['query'][] = $k2 . '=' . to_url($process[$k2]);
			break;
			case 'incident_id':
			case 'feedback_id':
				if ($interpret[$k1][$k2])
					$interpret['lookup']['query'][] = $k2 . '=' . to_url($v2);
			break;
			case 'kind_name_name':
				if ($interpret['lookup']['kind_name_id'])
					$interpret['query'][] = 'kind_name_id=' . (int)$interpret['lookup']['kind_name_id'];
			break;
			default:
				$s1 = str_replace('_name', '_id', $k2);
				if ($interpret['lookup'][$s1])
					$interpret['query'][] = $s1 . '=' . (int)$interpret['lookup'][$s1];
			break;
		}
	}
}

process_success(get_translation('transaction_complete'), $x['..'] . get_q_query($x['level'], implode('&', $interpret['query'])));
*/
